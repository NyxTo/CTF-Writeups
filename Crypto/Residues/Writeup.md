# Task
Without the modulus, you can't possibly decrypt my message, right?\
`nc challs.hats.sg 1400`\
Files: [chal.py](chal.py)

# Source Code
Important parts of `chal.py`:
```python
def genrsa(s):
    e = 65537
    r = randint(0, 4**s)
    p, q = next_prime(r), next_prime(r + randint(1, 2**s))
    if GCD(p-1, e) == GCD(q-1, e) == 1:
        return p * q, 2*e

def enc(m, e, n):
    return hex(pow(m, e, n))[2:].rstrip('L')

def main():
    n, e = genrsa(512)
    print 'Encrypted flag: ' + enc(flag, e, n)
    for _ in range(6):
        print 'Enter a value to be encrypted: '
        m = int(raw_input(), 16)
        print "Cipher: " + enc(m, e, n)
```
When `main()` is called, it generates an RSA cipher. It has:
 - Primes `p < q < 2**1024` with `q - p < 2**512`
 - Encryption key `e = 2*65537`.

Then 6 more custom messages can be encrypted.

# Method
First, we find `n`. For any message `m` and its cipher `c`, RSA means that `m**e - c` will be a multiple of `n`. Taking the GCD of `m**e - c` for multiple messages, it _should_ be `n` (_most likely_). To avoid possible redundancy, the messages should be coprime, so choose the first 6 primes, 2, 3, 5, 7, 11, and 13.\
Connecting to `nc challs.hats.sg 1400`:
```
Encrypted flag: 7850d33c252a8bbf967056899970cfe4039ad55e80ae5f88d040309010feae6f638fe64e4fdcbddca61643cff3b2057778b799387b491a379d85a474327bc8a46b2aa2eb346d1e0e4752281e319a72dfff6f804e452279df99f4f8002d5c9bb3e21eb96ed445105b941195f90e3032368e301e6bc245e2f99b088268447dcf5e2d1afe7aacb770a9057063a2170a5627d80809a67497a1a1d3b5dc33d5565cfcb323fcfed345a2f6fdc4308e07c52f80fed6589d3fda2169ca2aae1f23448b9c6e3cb41cba5122d62cd27c7557c4460787340fe48c4538d771d8f515389c82a9e45781d81880bc5a666bb6b81af0462b0072aea3e15ab652b125d188557f41
Enter a value to be encrypted: 2
Cipher: 808a6b414bdeb242d40af192137d0a417be357d9612a901812b1a7dcd7b7d7451d14463d8f5eccfaa5c7ad3b5ef39603e7021a933c3ea7fb3beb2c785f98cf7d66dc7b13413236c9585dabc43966991c7fa01341c1d648218edd27b59620065203de824ed413867db29dbf30f1c0f3125416b96d651f69fe3733ea061ed45de308a2aaceb05dd79187e6275c6f6a0350f5831385f963e55434d248e3c3ce6ed1e2c051592b36cea82f4b8dfefe55d20c7502e117dd116547a197bcdde0fa853f40871942ab6c8a2d8661aa41a26b6dffd0ed3a9e9e37abf40e8f56a126387c5645b3ab05cdeaf324ff5103a4734459a2073d4b344acff3aa2c4e25ff307b21
Enter a value to be encrypted: 3
Cipher: 16f3e1d1814be6f15ecb8ca4ca46401985be54f2e8134434f3d135d1f0e9394ba80cc83b945f5c26e583529f5563f367f0ccbed760d1af7b950cc437174f391a391551cec2b22dd7e419acc92f13fd3afaa6822a20289e778839ea976ac00f4c9e92ccbb35e35e134c96205361d90f47aff208d9eb3f05eacddb7c0fd8d788c6691da5d69e38bfaff50045ff94bce6b00d70d4819bb07fa3ba193e7aa978182eb282ed3acea049dcae033b673ed47c5357f3b2bacd0103d647663853cd42ccb8c973be2287ea8ab8c4a4e38cf87c4611f718fd37d8f3bfe6801c660baff2e999f2d574bdb22ce6f2a9de9be57350d658d77e92d99bb862adc5e54da2ccd7807
Enter a value to be encrypted: 5
Cipher: ae75ca40c124e29eed58cceb25c13bf5c0ef21d09399f074b33b1f5ba16e326222c6f23c33df2fe2c00f3e04fe82ea6566e1d491b3e4517c6e5b6390d2789ea89f13a28d4a020c7466f7c91b720ef5d23a3d16db279a0fffb6d4e5deb0d8a30d9a45c258bbccac80df81d9adaf0a35ae3e97ea010f4095131fc2f8b54d706e96433afe6e3df3de89d98cf686ac5631cf813cc8474e2d6df8e5afc34f654096b8048a77590a2833a56eb71197f3606c85fe38f07067f34e14cd1969516d95f6a4e0f81a299b903a02a46396ea3df483dd424d8d443cc59e1256addb8945651f03d6785dfc8183a78b2de07f8b958f28c46e157d074e209586f8f94de2be6949
Enter a value to be encrypted: 7
Cipher: 17992b4b69d808aa413cb7c60b40843db396ef363b4612bb4c7bf9d39d2682ead533c0a75b0b17c2f24a37058c966bca31a763c70c074f541757dbfa062173be2f2084bd118389a1eb1d78cbffa2cbb90aac2d965e2b3297cbf006aab73fcf5f5e04b70aa63e6b6161441a466a18679fc1d0ab178f713be83d57123e59b2f29e1bbe39fbe8b6c247c417bf52f1ff05e7136260ce45fff6961c9a70dfa52ddb1fb76a0fab7ab7f6465a66afb18b46f40dc756ffccf3e5aa8234beaf514d9dff8e346eeaff6620ce0e3640023f79a007cf3c492836758f8f7768b156a7139d2f9621639af42751b149b4c21ef507ae969fb3ed12861cf4bbab3ca4dd376e37cab
Enter a value to be encrypted: b
Cipher: de7a5e78463ab62ae392db183aad2d52be8cf375ac1768ad097cb6d9b96a47ef3e2d03fe809474c5656ff1f747bf94bb84f68c3f1d6ce88c77328e831d686b73ff9e1b245084050d4542a6c41c66d7c81788b5f63d384d96826f9d49e976338190fc6e4c382c45c95689eb2e08e39fbcd88988a3333edb6a441960bd3623fcc7f743ca59e034bd7ea46533c654fec5e1fc8b5372f51233eb29b578f7d33c9037ac30fd1105a722f6fb9d076a7f3d6a730c4be05ab53969b5837fa7e596bf3c88ef0b35317c7605df13e6398735f7c0004bebe49cbd8eebeda55d9ca07106aae2b63001a20c5c037fa5e18e946abf226ed3ece006760f46643d621eba3348af
Enter a value to be encrypted: d
Cipher: cf4acaa3572444f56902364291a34056fd639a9af194a96ab4847f47abea2d1302a332eabc47841e94e450dfc1c3c3fdaf25f9cbc7a3264bd0c93929c344c4d7c9e16eea890006ebdeecdcbffff1e66d4fc83895363759a7e0cc2d43f727bde977cfdcdb6f79cdc0deed0427863eab5788b698bad19d344d9d067012bdab18d2f0c6913a0e0216c1007b5f5e64fe0f1fc63dd9fd44f1ea76e8ea4973df100cb111ef46fb64c673fb399a8ba45977c63724feeb5198dcd0e7c79e1a9165ee639a9cf5959caee2eb852341999771a976ddb2876185577635ebd0ad988eb02c714ec14cad97cb57a91add9e03fbce2c190fcd16e7406d227d4fbacd2e6c028b74
```
Next, we factorise `n` to find `p` and `q`. Notice that the difference `q - p` is small compared to `p` and `q`. When the factors are close, [Fermat factorisation](https://en.wikipedia.org/wiki/Fermat%27s_factorization_method#Basic_method) is fast. The first step is to find the integer square root of `n`, which we do with [Newton's method](https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division).
```python
def isqrt(n):
    b = len(bin(n)[2:])
    r = 2**(b//2)
    # initial estimate 2**(b//2), where n has b bits
    while r**2 > n or (r+1)**2 <= n:
        r = (r + n//r) // 2
    return r

def fermat(n):
    a = isqrt(n) + 1
    while True:
        b2 = a*a - n
        b = isqrt(b2)
        if b**2 == b2:
            return a-b, a+b
        a += 1
```
As usual, set `phi = (p-1) * (q-1)`. Normally, the [Extended Euclidean Algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode) would let us find the decryption key `d` from `e` and `phi`. However, `e` is even and not coprime to `phi`, so this doesn't work. Instead, treat `m**2` as the message, and treat the encryption `m ** (2*65537)` as `(m**2) ** 65537`. Then decrypt as usual to find `flag**2` modulo `n`.
```python
def ext_euclid(a, b):
    c, d, x, y, v = a, b, 0, 1, []
    while c > 0:
        v.append(d // c)
        c, d = d % c, c
    for i in range(len(v)-1, -1, -1):
        x, y = y - v[i] * x, x
    if x < 0:
        x += b
        y -= a
    return x, y
```

# Solution
[soln.py](soln.py)
```python
from math import gcd

e = 2*65537
cflag = 0x7850d33c252a8bbf967056899970cfe4039ad55e80ae5f88d040309010feae6f638fe64e4fdcbddca61643cff3b2057778b799387b491a379d85a474327bc8a46b2aa2eb346d1e0e4752281e319a72dfff6f804e452279df99f4f8002d5c9bb3e21eb96ed445105b941195f90e3032368e301e6bc245e2f99b088268447dcf5e2d1afe7aacb770a9057063a2170a5627d80809a67497a1a1d3b5dc33d5565cfcb323fcfed345a2f6fdc4308e07c52f80fed6589d3fda2169ca2aae1f23448b9c6e3cb41cba5122d62cd27c7557c4460787340fe48c4538d771d8f515389c82a9e45781d81880bc5a666bb6b81af0462b0072aea3e15ab652b125d188557f41
c2 = 0x808a6b414bdeb242d40af192137d0a417be357d9612a901812b1a7dcd7b7d7451d14463d8f5eccfaa5c7ad3b5ef39603e7021a933c3ea7fb3beb2c785f98cf7d66dc7b13413236c9585dabc43966991c7fa01341c1d648218edd27b59620065203de824ed413867db29dbf30f1c0f3125416b96d651f69fe3733ea061ed45de308a2aaceb05dd79187e6275c6f6a0350f5831385f963e55434d248e3c3ce6ed1e2c051592b36cea82f4b8dfefe55d20c7502e117dd116547a197bcdde0fa853f40871942ab6c8a2d8661aa41a26b6dffd0ed3a9e9e37abf40e8f56a126387c5645b3ab05cdeaf324ff5103a4734459a2073d4b344acff3aa2c4e25ff307b21
c3 = 0x16f3e1d1814be6f15ecb8ca4ca46401985be54f2e8134434f3d135d1f0e9394ba80cc83b945f5c26e583529f5563f367f0ccbed760d1af7b950cc437174f391a391551cec2b22dd7e419acc92f13fd3afaa6822a20289e778839ea976ac00f4c9e92ccbb35e35e134c96205361d90f47aff208d9eb3f05eacddb7c0fd8d788c6691da5d69e38bfaff50045ff94bce6b00d70d4819bb07fa3ba193e7aa978182eb282ed3acea049dcae033b673ed47c5357f3b2bacd0103d647663853cd42ccb8c973be2287ea8ab8c4a4e38cf87c4611f718fd37d8f3bfe6801c660baff2e999f2d574bdb22ce6f2a9de9be57350d658d77e92d99bb862adc5e54da2ccd7807
c5 = 0xae75ca40c124e29eed58cceb25c13bf5c0ef21d09399f074b33b1f5ba16e326222c6f23c33df2fe2c00f3e04fe82ea6566e1d491b3e4517c6e5b6390d2789ea89f13a28d4a020c7466f7c91b720ef5d23a3d16db279a0fffb6d4e5deb0d8a30d9a45c258bbccac80df81d9adaf0a35ae3e97ea010f4095131fc2f8b54d706e96433afe6e3df3de89d98cf686ac5631cf813cc8474e2d6df8e5afc34f654096b8048a77590a2833a56eb71197f3606c85fe38f07067f34e14cd1969516d95f6a4e0f81a299b903a02a46396ea3df483dd424d8d443cc59e1256addb8945651f03d6785dfc8183a78b2de07f8b958f28c46e157d074e209586f8f94de2be6949
c7 = 0x17992b4b69d808aa413cb7c60b40843db396ef363b4612bb4c7bf9d39d2682ead533c0a75b0b17c2f24a37058c966bca31a763c70c074f541757dbfa062173be2f2084bd118389a1eb1d78cbffa2cbb90aac2d965e2b3297cbf006aab73fcf5f5e04b70aa63e6b6161441a466a18679fc1d0ab178f713be83d57123e59b2f29e1bbe39fbe8b6c247c417bf52f1ff05e7136260ce45fff6961c9a70dfa52ddb1fb76a0fab7ab7f6465a66afb18b46f40dc756ffccf3e5aa8234beaf514d9dff8e346eeaff6620ce0e3640023f79a007cf3c492836758f8f7768b156a7139d2f9621639af42751b149b4c21ef507ae969fb3ed12861cf4bbab3ca4dd376e37cab
c11 = 0xde7a5e78463ab62ae392db183aad2d52be8cf375ac1768ad097cb6d9b96a47ef3e2d03fe809474c5656ff1f747bf94bb84f68c3f1d6ce88c77328e831d686b73ff9e1b245084050d4542a6c41c66d7c81788b5f63d384d96826f9d49e976338190fc6e4c382c45c95689eb2e08e39fbcd88988a3333edb6a441960bd3623fcc7f743ca59e034bd7ea46533c654fec5e1fc8b5372f51233eb29b578f7d33c9037ac30fd1105a722f6fb9d076a7f3d6a730c4be05ab53969b5837fa7e596bf3c88ef0b35317c7605df13e6398735f7c0004bebe49cbd8eebeda55d9ca07106aae2b63001a20c5c037fa5e18e946abf226ed3ece006760f46643d621eba3348af
c13 = 0xcf4acaa3572444f56902364291a34056fd639a9af194a96ab4847f47abea2d1302a332eabc47841e94e450dfc1c3c3fdaf25f9cbc7a3264bd0c93929c344c4d7c9e16eea890006ebdeecdcbffff1e66d4fc83895363759a7e0cc2d43f727bde977cfdcdb6f79cdc0deed0427863eab5788b698bad19d344d9d067012bdab18d2f0c6913a0e0216c1007b5f5e64fe0f1fc63dd9fd44f1ea76e8ea4973df100cb111ef46fb64c673fb399a8ba45977c63724feeb5198dcd0e7c79e1a9165ee639a9cf5959caee2eb852341999771a976ddb2876185577635ebd0ad988eb02c714ec14cad97cb57a91add9e03fbce2c190fcd16e7406d227d4fbacd2e6c028b74

n = gcd(gcd(2**e - c2, 3**e - c3), 5**e - c5)
n = gcd(gcd(gcd(n, 7**e - c7), 11**e - c11), 13**e - c13)
print n # 197406745349723929024931007345687969040877112207893896169057067692980101845852019971494352017666211594307738950903251742995042500996072167408518402765128371242395569792123573076253565790991036878296322587218560020980575811990165525558706002244747112021453678362028613750257364071900184798861749312406756019682465316564839163349350821210030007073222842356041883712430482614429839002172017562356572899289727201775206503975404370011623052366876115249351743797917584128564564166318950723507383145405050287943392819947590795053531258975639357730711069029421117495329324859892140533529660973522234381184268955985626315739
p, q = fermat(n)
phi = (p-1) * (q-1)
d, _ = ext_euclid(e//2, phi)
flag2 = pow(cflag, d, n)
print flag2 # 47895708736345603730993027873792331310839889122796437773405768887316342994997501121979030756132047635855110921

print hex(isqrt(flag2))[2:].decode('hex') # HATS{50m3_r351du3_l3f7}
```
Notice that `flag2` is much smaller than `n`, which indicates it is the actual value of `flag**2`, without needing to take modulo `n`. Finally, take the square root to get the flag: `HATS{50m3_r351du3_l3f7}`.
