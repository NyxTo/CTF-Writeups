## Encryptdle

A popular word game, but encrypted.

### Analysis
We are given [`server.py`](server.py):

```py
import os
from typing import List
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from fastapi import FastAPI, Query
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
import uvicorn

try:
    with open('flag.txt', 'rb') as f:
        FLAG = f.read()
except:
    FLAG = b'FLAGFLAGFLAGFLAGFLAGFLAGFLAGFLAG'

KEY = os.urandom(32)
IV = os.urandom(16)
MAX_LEN = 32

def pad(bstring):
    return (bstring + FLAG + b'\x00' * MAX_LEN)[:MAX_LEN]


def encrypt(bstring):
    padded_data = pad(bstring)
    cipher = Cipher(algorithms.Camellia(KEY), modes.CBC(IV))
    encryptor = cipher.encryptor()
    return encryptor.update(padded_data) + encryptor.finalize()


ANSWER = encrypt(FLAG).hex().upper()


# correct, present, absent
def judge(guess, answer):
    ALPHABET = '0123456789ABCDEF'
    result = [{'letter': c, 'presence': 'absent'} for c in guess]
    count = [0 for i in range(len(ALPHABET))]
    for c in answer:
        count[int(c, 16)] += 1
    for i in range(len(guess)):
        if(guess[i] == answer[i]):
            result[i]['presence'] = 'correct'
            count[int(guess[i], 16)] -= 1
    for i in range(len(guess)):
        if(result[i]['presence'] == 'correct'):
            continue
        if(count[int(guess[i], 16)] > 0):
            result[i]['presence'] = 'present'
            count[int(guess[i], 16)] -= 1
    return result


app = FastAPI()


class LetterResult(BaseModel):
    letter: str
    presence: str


@app.post("/api/compare", response_model=List[LetterResult])
async def compare(guess: str = Query(..., min_length=1, max_length=MAX_LEN)):
    enc_guess = encrypt(guess.encode()).hex().upper()
    return judge(enc_guess, ANSWER)


@app.get("/api/ping")
async def ping():
    return "pong"


app.mount("/", StaticFiles(directory="frontend/dist/", html=True), name="static")

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=80)
```

When we guess a string, it goes through a few stages:
 - The `pad()` function pads it to the right with the flag and null bytes, then sliced at `32` characters,
 - The `encrypt()` function puts the padded string through the Camellia cipher algorithm, with a CBC block cipher mode,
 - The hex of the encrypted string goes through the `judge()` function to determine each letter's presence according to standard Wordle rules.

If we are not familiar with the Camellia cipher algorithm, we do a quick Google search. The Wikipedia page https://en.wikipedia.org/wiki/Camellia_(cipher)#Security_analysis tells us that it is safe by modern standards, with high security levels. The key and IV used are generated by `os.urandom()`, considered cryptographically random, eligible to be used in ciphers. These are definitely not our break through into the vulnerability of the challenge.

The Camellia algorithm is a block cipher with block size 128 bits. Since we can guess strings of at most `MAX_LEN = 32` characters, this means up to two blocks are encrypted each time. With a secure algorithm, each block is practically put through a random permutation, and no relationship between the plaintext block and ciphertext block can be known without brute forcing all possibilities for the key. Here the Wordle rules are of no use to us, as what matters is solely whether one entire block remains the same or not, and we can check that without the letter presence. The only thing we can take advantage of is that the key and IV are kept the same through all occurrences of encryption. This means the same string always encrypts the same way.

### Approach
However, the string we guess is different from the string being encrypted. The `pad()` function is between those two, and this hints us as to our approach. We should find different plaintext strings to guess, and if their corresponding ciphertexts are the same, we infer that the _padded_ plaintexts are the same. Making use of the `pad()` function slicing at `32` characters, varying the length of the guess string also varies the length of the flag that is padded. On the other hand, padding a string with exactly `MAX_LEN = 32` characters leaves it unchanged.

Final method:
 - Guess `'a'*31`, it will be padded with the first character of the flag, `FLAG[0]` or `FLAG[:1]`.
 - Guess `'a'*31 + char` for each ASCII printable character. The character that results in the same ciphertext is the first character of the flag, `FLAG[0]`.
 - Guess `'a'*30`, it will be padded with the first two characters of the flag, `FLAG[:2]`.
 - Guess `'a'*30 + FLAG[:1] + char` for each ASCII printable character. The character that results in the same ciphertext is the second character, `FLAG[1]`.
 - Guess `'a'*29` and `'a'*29 + FLAG[:2] + char` to get `FLAG[2]`.
 - Continue this way, linearly checking all possibilities for each character one by one, until we reveal the entire flag.

As the `@app.post("/api/compare", response_model=List[LetterResult])` decorator shows, to submit a guess, we need to make an HTTP POST request to that URL with a `guess` parameter. The response will be a `List[LetterResult]`, where each `LetterResult` has a `letter` and a `presence` attribute. When dumped into JSON and loaded back into Python, that becomes a list of dictionaries, each with a `"letter"` and `"presence"` key. The presences can be disregarded as mentioned before, and we combine the letters in order into a string. We do this with the Python `requests` and `json` modules.

```py
import requests
import json

def guess(payload):
    resp = requests.post(f'http://{SERVER}:{PORT}/api/compare', params={'guess': payload})
    return ''.join(res['letter'] for res in json.loads(resp.text))

flag = ''
for i in range(32):
    try:
        target = guess('a' * (31-i))
    except Exception:
        break
    for ch in range(32, 127):
        if guess('a' * (31-i) + flag + chr(ch)) == target:
            flag += chr(ch)
            break
    print(flag)
```

As the CTF was hosted on Hack The Box, the server IP and port were generated by spawning a docker instance on the HTB website. Proceed using the `guess()` function in the method, testing each ASCII printable character in the inner loop. In the outer loop, use one less `'a'` on each subsequent iteration, and break when the HTTP response is no longer in the format we expect, since the end of the flag is reached. The characters gradually reveal the flag `STF22{iNS3CuR3!_S+4+iC_IVs!!}`.
